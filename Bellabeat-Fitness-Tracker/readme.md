
# Bellabeat Case Study: SQL Analysis

## ðŸ“Œ Introduction  
[Bellabeat](https://bellabeat.com/) is a Fem-tech company that manufactures health-focused smart devices to help millions of women track their cycle,
pregnancies, and live more in sync with their cycles. This case study focuses on analyzing data generated by Bellabeat tracker users to provide actionable insights on activity, sleep patterns, and weight trends using SQL.

---

## ðŸ’» Tools and Technologies  
- **SQL**: PostgreSQL for querying datasets  
- **pgAdmin**: Interface for database management  
- **Datasets**: `User_activity`, `sleep_day`, and `weight_logs` 

---

## ðŸ“Š Datasets  

| Dataset         | Description                                                                           |
|------------------|---------------------------------------------------------------------------------------|
| `daily_activity` | Tracks user activity, including steps, calories burned, and activity minutes         |
| `sleep_day`      | Logs sleep duration and efficiency metrics                                           |
| `weight_log`     | Records user weight and BMI over time                                                |

You can find the datasets [here](SQL-Case-Studies/Bellabeat-Fitness-Tracker/Dataset/).

---
## ERD
![diagram](SQL-Case-Studies/Bellabeat-Fitness-Tracker/Bellabeat_ERD.png)

---
## ðŸ” Case Study Objectives  

This project addresses the following analytical questions:  

1. Which day of the week has the highest activity levels?  
2. What is the correlation between sleep efficiency and activity?  
3. What is the most frequently logged day of the week across all datasets?  

---

## ðŸ“ SQL Queries  


### 1. Identify the day of the week when the customers are most active and least active. Active is determined based on the no of steps. 

```sql
WITH cte AS(
	SELECT 
		day_of_week
		, SUM(total_steps) AS activity
FROM daily_activity
GROUP BY day_of_week
)
SELECT 
	'most_active' AS customer_activity
	, day_of_week 
FROM cte 
WHERE activity = (SELECT MAX(activity) FROM cte)
UNION ALL
SELECT 
	'least_active' AS Customer_activity
	, day_of_week 
FROM cte 
WHERE activity = (SELECT MIN(activity) FROM cte)

/* OUTPUT
| customer_activity | day_of_week |
| ----------------- | ----------- |
| most_active       | Tuesday     |
| least_active      | Sunday      |
*/


-- OUTPUT in One Row
WITH cte AS (
    SELECT 
        day_of_week 
        , SUM(total_steps) AS activity
    FROM daily_activity
    GROUP BY day_of_week
)
SELECT 
    (SELECT day_of_week FROM cte WHERE activity = (SELECT MAX(activity) FROM cte)) AS most_active_day
    , (SELECT day_of_week FROM cte WHERE activity = (SELECT MIN(activity) FROM cte)) AS least_active_day;
/*
| most_active_day | least_active_day |
| --------------- | ---------------- |
| Tuesday         | Sunday           |
*/
```


### 2. Identify the customer who has the most effective sleep. Effective sleep is determined based on is customer spent most of the time in bed sleeping.
```sql
SELECT 
    customer_Id
	, SUM(total_time_in_bed) AS total_time_in_bed
	, SUM(total_minutes_asleep) AS total_minutes_asleep
    , (SUM(total_time_in_bed) - SUM(total_minutes_asleep)) AS total_minutes_awake_in_bed
FROM sleep_day
/*To avoid invalid or zero bed time entries we can filter further
,but in our Data we do have sleep enteries for all customers
-- WHERE total_time_in_bed > 0. */
GROUP BY customer_Id
ORDER BY total_minutes_awake_in_bed
LIMIT 1;

/* OUTPUT
| customer_id | total_time_in_bed | total_minutes_asleep | total_minutes_awake_in_bed |
| ----------- | ----------------- | -------------------- | -------------------------- |
| 7007744171  | 143               | 137                  | 6                          |
*/
```

### 3. Identify customers with no sleep record.

```sql
-- USING JOIN
SELECT d.customer_id
FROM daily_Activity d
LEFT JOIN sleep_day s ON d.customer_id = s.customer_id
-- WHERE s.customer_id IS NULL
GROUP BY d.customer_id
-- I prefer the COUNT using HAVING
HAVING COUNT(s.customer_id) = 0

-- Using SUBQUERY
SELECT DISTINCT Customer_ID
FROM daily_activity
WHERE Customer_ID NOT IN (SELECT DISTINCT Customer_Id FROM sleep_day);

-- For better efficiency using joins would be better

/* OUTPUT
| customer_id(JOIN) |     | customer_id(SUBQUERY) |
| ----------------- |     | --------------------- |
| 1624580081        |     | 1624580081            |
| 4057192912        |     | 4057192912            |
| 8253242879        |     | 8253242879            |
| 3372868164        |     | 3372868164            |
| 8877689391        |     | 8877689391            |
| 6290855005        |     | 6290855005            |
| 2022484408        |     | 2022484408            |
| 2873212765        |     | 2873212765            |
| 8583815059        |     | 8583815059            |

*/
```

### 4. Fetch all customers whose daily activity, sleep and weight logs are all present.
```sql
SELECT DISTINCT d.customer_id
FROM daily_Activity d
JOIN sleep_day s ON s.customer_id = d.customer_id
JOIN weight_log w ON w.customer_id = s.customer_id

/* OUTPUT
| customer_id |
| ----------- |
| 4558609924  |
| 4319703577  |
| 5577150313  |
| 1927972279  |
| 1503960366  |
| 6962181067  |
*/
```

### 5. For each customer, display the total hours they slept for each day of the week. Your output should contains 8 columns, first column is the customer id and the next 7 columns are the day of the week (like Monday, Tuesday, etc..)

```sql
SELECT customer_id
-- Dividing by 60 to convert the sleep_time in Minutes to sleep_time in Hours
	, ROUND(SUM(CASE WHEN day_of_week = 'Monday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Monday
	, ROUND(SUM(CASE WHEN day_of_week = 'Tuesday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Tuesday
	, ROUND(SUM(CASE WHEN day_of_week = 'Wednesday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Wednesday
	, ROUND(SUM(CASE WHEN day_of_week = 'Thursday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Thursday
	, ROUND(SUM(CASE WHEN day_of_week = 'Friday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Friday
	, ROUND(SUM(CASE WHEN day_of_week = 'Saturday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Saturday
	, ROUND(SUM(CASE WHEN day_of_week = 'Sunday' THEN total_minutes_asleep:: DECIMAL END) / 60,1) AS Sunday
FROM sleep_day
GROUP BY customer_id

/* OUTPUT
| customer_id | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday |
| ----------- | ------ | ------- | --------- | -------- | ------ | -------- | ------ |
| 4558609924  | null   | 1.7     | null      | 2.1      | 2.9    | null     | 4      |
| 7086361926  | 21.9   | 32.1    | 38.1      | 27.7     | 18.8   | 16.9     | 25.8   |
| 8378563200  | 24.9   | 33.7    | 36.1      | 36.7     | 30.1   | 35.1     | 33.4   |
| 2320127002  | null   | null    | null      | null     | null   | 1        | null   |
| 4319703577  | 33.6   | 32.1    | 22.3      | 23.2     | 32.9   | 36.6     | 25.9   |
| 5577150313  | 24.6   | 37.2    | 39        | 22.1     | 19.8   | 20       | 24.5   |
| 4445114986  | 21.5   | 33.2    | 33        | 37.4     | 20.1   | 19.8     | 15     |
| 2026352035  | 25.8   | 22.6    | 42.7      | 41       | 34.3   | 35.5     | 34.3   |
| 1927972279  | null   | 17.4    | 6.6       | 2.8      | 7.9    | null     | null   |
| 1844505072  | null   | null    | null      | null     | 10.7   | 12       | 9.8    |
| 5553957443  | 30.3   | 33.5    | 39.5      | 33.9     | 25.8   | 41.7     | 34.9   |
| 3977333714  | 15.1   | 22.5    | 16.8      | 20       | 23.9   | 16.5     | 22.2   |
| 7007744171  | null   | null    | null      | null     | null   | 1.3      | 1      |
| 6962181067  | 30     | 35.8    | 40        | 39.7     | 27.9   | 26.8     | 31.5   |
| 6775888955  | null   | null    | 3.9       | 7.1      | 6.5    | null     | null   |
| 6117666160  | 16.4   | 7.8     | 16.9      | 21.6     | 29     | 22.8     | 29.2   |
| 2347167796  | 15.6   | 15      | 15.3      | 21.9     | 21.1   | 6.2      | 16.6   |
| 8053475328  | null   | null    | 8.1       | null     | null   | 6.8      | null   |
| 4388161847  | 8.8    | 16.7    | 28.7      | 22.4     | 9.7    | 29.8     | 37.5   |
| 1503960366  | 14.9   | 25.5    | 17.2      | 15.6     | 18.1   | 23.9     | 34.9   |
| 4702921684  | 18.3   | 34.1    | 34.2      | 34.5     | 18.2   | 30.8     | 17.9   |
| 1644430081  | 13.3   | null    | null      | null     | 2      | 2.1      | 2.3    |
| 8792009665  | 6.9    | 16.2    | 32        | 14.8     | 19.2   | 11.4     | 8.4    |
| 4020332650  | null   | 21.1    | 8         | 3.8      | 6.4    | 1.3      | 6.1    |
*/
```


### 6. For each customer, display the following: customer_id, date when they had the highest_weight(also mention weight in kg)

```sql
SELECT 
	customer_id
	, dates
	, MAX(weight_kg) AS highest_weight
	-- , MIN(weight_kg) AS lowest_weight
FROM weight_log
GROUP BY customer_id, dates

/* OUTPUT
Long list as it's for all Customers, please run the query to verify the OUTPUT :)
*/
```

### 7. Fetch the day when customers sleep the most.
```sql
WITH cte AS (
SELECT day_of_week
	, SUM(total_minutes_asleep) AS total_minutes_slept
FROM sleep_day
GROUP BY day_of_week
)
SELECT day_of_week
FROM cte
WHERE total_minutes_slept = (SELECT MAX(total_minutes_slept) FROM cte);

-- OR using ORDER BY and LIMIT 
SELECT day_of_week
	, SUM(total_minutes_asleep) AS total_minutes_slept
FROM sleep_day
GROUP BY day_of_week
ORDER BY total_minutes_slept DESC
LIMIT 1;

-- in the CTE + SUBQUERY appraoch the SUBQUERY will run an extra scan.

/* OUTPUT
 CTE + SUBQUERY                ORDER BY - LIMIT
| day_of_week |     | day_of_week | total_minutes_slept |
| ----------- |     | ----------- | ------------------- |
| Wednesday   |     | Wednesday   | 28689               |
*/
```


### 8. For each day of the week, determine the percentage of time customers spend lying on bed without sleeping.

```sql
-- This approach will consider Overall percentage of total_awake_time for all records combined for each day
SELECT 
    day_of_week,
    ROUND(
        (SUM(Total_Time_In_Bed) - SUM(Total_Minutes_Asleep))::DECIMAL / SUM(Total_Time_In_Bed) * 100, 2
    ) AS pct_awake_time_in_bed
FROM sleep_day
GROUP BY day_of_week;

-- Second approach - Avg percentage of awake_time for each record / Average behaviour of individual records
SELECT day_of_week
	, ROUND(
		AVG(
			(Total_Time_In_Bed - Total_Minutes_Asleep):: DECIMAL / Total_Time_In_Bed
			) * 100
			,2) AS pct_awake_time_in_bed
FROM sleep_day
GROUP BY day_of_week

/* OUTPUT
 -- First Approach                             -- Second Approach
| day_of_week | pct_awake_time_in_bed |     | pct_awake_time_in_bed | pct_awake_time_in_bed |
| ----------- | --------------------- |     | --------------------- | --------------------- |
| Tuesday     | 8.74                  |     | Tuesday               | 8.91                  |
| Saturday    | 8.87                  |     | Saturday              | 8.5                   |
| Thursday    | 7.72                  |     | Thursday              | 7.73                  |
| Friday      | 8.9                   |     | Friday                | 7.99                  |
| Wednesday   | 7.52                  |     | Wednesday             | 7.87                  |
| Sunday      | 10.08                 |     | Sunday                | 9.49                  |
| Monday      | 8.28                  |     | Monday                | 8.03                  |
*/
```



### 9. Identify the most repeated day of week. Repeated day of week is when a day has been mentioned the most in entire database.

```sql
SELECT day_of_week
	, COUNT(1) as total_days
FROM (
	SELECT day_of_week FROM daily_activity
	UNION ALL
	SELECT day_of_week FROM sleep_day
	UNION ALL
	SELECT day_of_week FROM weight_log
	) c
GROUP BY day_of_week
ORDER BY total_days DESC
LIMIT 1;

/* OUTPUT
| day_of_week | total_days |
| ----------- | ---------- |
| Wednesday   | 228        |
*/
```
 
### 10. Based on the given data, identify the average kms a customer walks based on 6000 steps.

```sql
SELECT 
	ROUND(AVG((Total_Distance / Total_Steps) * 6000),2)||' Kms' AS Avg_Km_Walked_For_6000_Steps
FROM daily_activity
WHERE Total_Steps > 0

/* OUTPUT

| Avg_Km_Walked_For_6000_Steps |
| ---------------------------- |
| 4.24 Kms                     |
*/
```

---

## ðŸ“ˆ Insights  

1. **Activity Trends**: Wednesday consistently shows the highest activity levels.  
2. **Sleep & Activity**: A positive correlation is observed between higher activity levels and better sleep efficiency.  
3. **Data Frequency**: Wednesday is the most frequently logged day across datasets, highlighting user consistency mid-week.  

---

## ðŸš€ Getting Started  

### Prerequisites  
1. Install PostgreSQL: [Download](https://www.postgresql.org/download/)  
2. Set up pgAdmin for database management.  

### Steps to Reproduce  
1. Clone the repository:  
   ```bash
   git clone https://github.com/lmdata10/SQL-Case-Studies.git
   cd Bellabeat-Fitness-Tracker
   ```  
2. Import the datasets into your PostgreSQL database.  
3. Execute the provided SQL queries in the [`Scripts`](Bellabeat-Fitness-Tracker/Scripts) folder.

## ðŸš€ Let's Connect and Share Ideas!

If you found this case study interesting, please try it out yourself! Iâ€™d love it if you could connect with me on [LinkedIn](https://www.linkedin.com/in/lmahial/) and share your thoughts or approach towards it. Always trying to learn a thing or two from fellow data enthusiasts!

Keep Querying, keep practicing, and most importantly, keep having fun with data! ðŸŒŸ




